#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "linkedlist.h"
#include "value.h"
#include "talloc.h"
#include "assert.h"
#include "parser.h"


/*
 * Function to put values on the stack
 * Value *stack: the stack of tokens
 * Value *token: the value box of the item to add
 * returns: the stack with the new value box on top
 */
Value *push(Value *stack, Value *token) {
    stack = cons(token, stack);
    return stack;
}

/*
 * Function to take values off of the stack
 * returns: Value box of item that was at the top of the stack
 */
Value *pop(Value *stack, Value **popped) {
    *popped = stack->c.car;
    stack = stack->c.cdr;
    return stack;
}
/*
 * Function that prints out an error message if
 * a syntax error has occurred and frees all memory
 */
void syntaxError() {
    printf("Syntax error encountered\n");
    texit(1);
}
/*
 * Function that parses the list of tokens generated by tokenizer
 * Value *tokens: the list of tokens
 * returns: a tree of tokens (without parens) of type Value
 */
Value *parse(Value *tokens) {
    Value *stack = makeNull();
    Value *popped = talloc(sizeof(Value));
    int depth = 0;
    Value *current = tokens;
    assert(current != NULL && "Error (parse): null pointer");
    while (current->type != NULL_TYPE) {
        Value *token = car(current);
        if (token->type !=CLOSE_TYPE) {
            if (token->type == OPEN_TYPE) {
                printf("open paren reached depth is %i\n", depth);
                depth++;
            }
            stack = push(stack, token);
        } else {
            depth--;
            printf("close paren reached depth is %i\n", depth);
            if (depth < 0) {
                printf("Too many close parentheses\n");
                syntaxError();
            }
            Value *tempList = makeNull();
            stack = pop(stack, &popped);
            while (popped->type != OPEN_TYPE) {
                tempList = cons(popped, tempList);
                stack = pop(stack, &popped);

            }
            stack = push(stack, tempList);
        }
        current = cdr(current);
    }
    if (depth != 0) {
        printf("Not enough close parentheses\n");
        syntaxError();
    }
    Value *tree = stack;
    Value *reverseTree = reverse(tree);
    return reverseTree;
}

/*
 * Prints the tree to the screen in a readable fashion.
 * Value *tree: the pointer to the tree
 */
void printTree(Value *tree) {
    while (tree->type != NULL_TYPE) {
        printSubTree(tree->c.car, true);
        tree = tree->c.cdr;
    }
}

/*
 * Helper function to print out the subtrees with parentheses in the correct places
 * Value *subtree: a sublist of the tree
 * bool first: tells the program to print a paren in front of the first CONS_TYPE
 */
void printSubTree(Value *subtree, bool first) {
    if (subtree->type == CONS_TYPE) {
        if(first || subtree->c.car->type == CONS_TYPE){
            printf("(");
            first = false;
        }
        printSubTree(subtree->c.car, first);
        printSubTree(subtree->c.cdr, first);
        if (subtree->c.car->type == CONS_TYPE || subtree->c.cdr->type != CONS_TYPE) { /* Special thanks to Logan for this*/
            printf(")");
        }
    } else
        switch(subtree->type) {
            case SYMBOL_TYPE:
                printf("%s ", subtree->s);
                break;
            case INT_TYPE:
                printf("%i ", subtree->i);
                break;
            case DOUBLE_TYPE:
                printf("%f ", subtree->d);
                break;
            case BOOL_TYPE:
                if (subtree->i == 1) {
                    printf("#t ");
                } else if (subtree->i == 0) {
                    printf("#f ");
                }
                break;
            case STR_TYPE:
                printf("%s ", subtree->s);
                break;
            case CONS_TYPE:
                printf("switch is cons\n");
                break;
            case NULL_TYPE:
                break;
            default:
                printf("error in printSubTree\n");
        }
}
